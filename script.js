class VietnameseVocabularyLearner {
  constructor() {
    // Tr·∫°ng th√°i h·ªçc t·∫≠p
    this.learningState = {
      vocabularyQueue: [], // H√†ng ƒë·ª£i t·ª´ v·ª±ng ch·ªù h·ªçc
      completedWords: new Set(), // T·ª´ ƒë√£ ho√†n th√†nh (tr·∫£ l·ªùi ƒë√∫ng)
      currentWord: null,
      currentOptions: [],
      correctAnswer: "",
      totalWords: 0,
      totalAttempts: 0,
      correctAttempts: 0,
      currentPosition: 0,
      isPaused: false,
    }

    // Th√¥ng ƒëi·ªáp ph·∫£n h·ªìi b·∫±ng ti·∫øng Vi·ªát
    this.feedbackMessages = {
      success: [
        "üéâ Tuy·ªát v·ªùi! B·∫°n ƒë√£ tr·∫£ l·ªùi ƒë√∫ng!",
        "üåü Xu·∫•t s·∫Øc! Ti·∫øp t·ª•c nh∆∞ v·∫≠y!",
        "‚ú® R·∫•t t·ªët! B·∫°n ƒëang h·ªçc r·∫•t nhanh!",
        "üéØ Ch√≠nh x√°c! B·∫°n th·∫≠t gi·ªèi!",
        "üöÄ Tuy·ªát v·ªùi! B·∫°n ƒëang ti·∫øn b·ªô!",
        "üí´ Ho√†n h·∫£o! T·ª´ n√†y b·∫°n ƒë√£ thu·ªôc r·ªìi!",
        "üèÜ T√†i gi·ªèi! C·ªë g·∫Øng ti·∫øp nh√©!",
        "‚≠ê Gi·ªèi l·∫Øm! B·∫°n h·ªçc r·∫•t t·ªët!",
      ],
      error: [
        "ü§î Ch∆∞a ƒë√∫ng r·ªìi! T·ª´ n√†y s·∫Ω xu·∫•t hi·ªán l·∫°i sau!",
        "üí™ G·∫ßn ƒë√∫ng r·ªìi! B·∫°n s·∫Ω g·∫∑p l·∫°i t·ª´ n√†y!",
        "üéØ ƒê·ª´ng lo! T·ª´ n√†y s·∫Ω ƒë∆∞·ª£c l·∫∑p l·∫°i!",
        "üåà Sai r·ªìi! H√£y nh·ªõ k·ªπ ƒë·ªÉ l·∫ßn sau ƒë√∫ng!",
        "üé™ Kh√¥ng sao! T·ª´ n√†y s·∫Ω quay l·∫°i sau!",
        "üé® Ti·∫øp t·ª•c c·ªë g·∫Øng! B·∫°n s·∫Ω g·∫∑p l·∫°i t·ª´ n√†y!",
        "üé≠ Ch∆∞a ƒë√∫ng! T·ª´ n√†y s·∫Ω xu·∫•t hi·ªán l·∫°i!",
        "üé™ ƒê·ª´ng b·ªè cu·ªôc! L·∫ßn sau b·∫°n s·∫Ω ƒë√∫ng!",
      ],
    }

    this.initializeEventListeners()
    this.setupMobileOptimizations()
  }

  initializeEventListeners() {
    // File upload
    document.getElementById("file-input").addEventListener("change", (e) => {
      this.handleFileUpload(e.target.files[0])
    })

    // Demo button
    document.getElementById("load-demo").addEventListener("click", () => {
      this.loadDemoVocabulary()
    })

    // Control buttons
    document.getElementById("pause-learning").addEventListener("click", () => {
      this.togglePause()
    })

    document.getElementById("restart-session").addEventListener("click", () => {
      this.restartSession()
    })

    document.getElementById("restart-learning").addEventListener("click", () => {
      this.restartSession()
      this.hideCompletionModal()
    })
  }

  setupMobileOptimizations() {
    // Prevent zoom on input focus
    const viewport = document.querySelector('meta[name="viewport"]')
    if (viewport) {
      viewport.setAttribute("content", "width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no")
    }

    // Prevent pull-to-refresh
    document.body.style.overscrollBehavior = "none"

    // Add touch feedback
    document.addEventListener("touchstart", () => {}, { passive: true })
  }

  async handleFileUpload(file) {
    if (!file) return

    try {
      const text = await this.readFileAsText(file)
      this.parseVocabularyFile(text)
      this.showFeedback("üìÅ T·∫£i file th√†nh c√¥ng! B·∫Øt ƒë·∫ßu h·ªçc ngay!", "success")
      setTimeout(() => this.startLearningSession(), 1000)
    } catch (error) {
      this.showFeedback("‚ùå L·ªói t·∫£i file!", "error")
      console.error("File loading error:", error)
    }
  }

  readFileAsText(file) {
    return new Promise((resolve, reject) => {
      const reader = new FileReader()
      reader.onload = (e) => resolve(e.target.result)
      reader.onerror = (e) => reject(e)
      reader.readAsText(file)
    })
  }

  parseVocabularyFile(text) {
    const lines = text.split("\n").filter((line) => line.trim())
    const vocabulary = []

    lines.forEach((line) => {
      const parts = line.split(" - ")
      if (parts.length === 2) {
        vocabulary.push({
          english: parts[0].trim().toLowerCase(),
          vietnamese: parts[1].trim(),
        })
      }
    })

    if (vocabulary.length === 0) {
      throw new Error("Kh√¥ng t√¨m th·∫•y t·ª´ v·ª±ng h·ª£p l·ªá")
    }

    // X√°o tr·ªôn t·ª´ v·ª±ng
    this.shuffleArray(vocabulary)

    // Kh·ªüi t·∫°o tr·∫°ng th√°i h·ªçc t·∫≠p
    this.learningState.vocabularyQueue = [...vocabulary]
    this.learningState.totalWords = vocabulary.length
    this.learningState.completedWords.clear()
    this.learningState.currentPosition = 0
    this.learningState.totalAttempts = 0
    this.learningState.correctAttempts = 0
  }

  async loadDemoVocabulary() {
    try {
      // T·∫£i file word.txt m·∫´u
      const response = await fetch("word.txt")
      const text = await response.text()
      this.parseVocabularyFile(text)
      this.showFeedback("üéÆ T·∫£i t·ª´ v·ª±ng m·∫´u th√†nh c√¥ng!", "success")
      setTimeout(() => this.startLearningSession(), 1000)
    } catch (error) {
      this.showFeedback("‚ùå Kh√¥ng th·ªÉ t·∫£i t·ª´ v·ª±ng m·∫´u!", "error")
      console.error("Demo loading error:", error)
    }
  }

  startLearningSession() {
    if (this.learningState.vocabularyQueue.length === 0) {
      this.showFeedback("üìù Vui l√≤ng t·∫£i file t·ª´ v·ª±ng tr∆∞·ªõc!", "error")
      return
    }

    // Hi·ªÉn th·ªã giao di·ªán h·ªçc t·∫≠p
    document.getElementById("file-upload-section").style.display = "none"
    document.getElementById("progress-container").style.display = "block"
    document.getElementById("learning-interface").style.display = "flex"
    document.getElementById("control-panel").style.display = "flex"

    this.updateAllDisplays()
    this.presentNextWord()
  }

  presentNextWord() {
    if (this.learningState.isPaused) return

    // Ki·ªÉm tra xem ƒë√£ ho√†n th√†nh t·∫•t c·∫£ t·ª´ ch∆∞a
    if (this.learningState.vocabularyQueue.length === 0) {
      this.showCompletionModal()
      return
    }

    // L·∫•y t·ª´ ƒë·∫ßu ti√™n trong h√†ng ƒë·ª£i
    this.learningState.currentWord = this.learningState.vocabularyQueue[0]
    this.learningState.currentPosition = this.learningState.totalWords - this.learningState.vocabularyQueue.length + 1

    // T·∫°o 6 l·ª±a ch·ªçn thay v√¨ 5
    this.generateOptionsWithDistractors(this.learningState.currentWord)

    // C·∫≠p nh·∫≠t giao di·ªán
    this.renderWordPresentation()
    this.updateAllDisplays()
  }

  generateOptionsWithDistractors(correctWord) {
    const options = [correctWord.vietnamese]

    // T·∫°o danh s√°ch t·∫•t c·∫£ t·ª´ v·ª±ng ƒë·ªÉ ch·ªçn ƒë√°p √°n sai
    const allVocabulary = [...this.learningState.vocabularyQueue, ...Array.from(this.learningState.completedWords)]

    // L·ªçc ra c√°c t·ª´ kh√°c ƒë·ªÉ l√†m ƒë√°p √°n sai
    const otherWords = allVocabulary.filter((word) => word.english !== correctWord.english)

    // X√°o tr·ªôn v√† ch·ªçn 5 t·ª´ l√†m ƒë√°p √°n sai (t·ªïng c·ªông 6 l·ª±a ch·ªçn)
    const shuffledOthers = [...otherWords].sort(() => Math.random() - 0.5)
    for (let i = 0; i < 5 && i < shuffledOthers.length; i++) {
      options.push(shuffledOthers[i].vietnamese)
    }

    // X√°o tr·ªôn th·ª© t·ª± c√°c l·ª±a ch·ªçn
    this.shuffleArray(options)

    this.learningState.currentOptions = options
    this.learningState.correctAnswer = correctWord.vietnamese
  }

  renderWordPresentation() {
    const word = this.learningState.currentWord

    // Hi·ªÉn th·ªã t·ª´ ti·∫øng Anh
    document.getElementById("target-word").textContent = word.english.toUpperCase()

    // X√°c ƒë·ªãnh lo·∫°i t·ª´
    const wordType = document.getElementById("word-type")
    const isRetry = Array.from(this.learningState.completedWords).some((w) => w.english === word.english)

    if (isRetry) {
      wordType.textContent = "L·∫∑p l·∫°i"
      wordType.style.background = "linear-gradient(45deg, #ff9800, #f57c00)"
    } else {
      wordType.textContent = "T·ª´ m·ªõi"
      wordType.style.background = "linear-gradient(45deg, #667eea, #764ba2)"
    }

    // T·∫°o 6 l·ª±a ch·ªçn
    const optionsGrid = document.getElementById("options-grid")
    optionsGrid.innerHTML = ""

    this.learningState.currentOptions.forEach((option, index) => {
      const optionCard = document.createElement("div")
      optionCard.className = "option-card"
      optionCard.textContent = option

      // Th√™m haptic feedback cho mobile
      optionCard.addEventListener(
        "touchstart",
        () => {
          if (navigator.vibrate) {
            navigator.vibrate(10) // Rung nh·∫π 10ms
          }
        },
        { passive: true },
      )

      optionCard.addEventListener("click", () => this.handleOptionSelection(option, optionCard))
      optionsGrid.appendChild(optionCard)
    })
  }

  handleOptionSelection(selectedOption, optionElement) {
    const isCorrect = selectedOption === this.learningState.correctAnswer

    // V√¥ hi·ªáu h√≥a t·∫•t c·∫£ l·ª±a ch·ªçn
    document.querySelectorAll(".option-card").forEach((card) => {
      card.classList.add("disabled")
    })

    // Hi·ªáu ·ª©ng th·ªã gi√°c
    optionElement.classList.add(isCorrect ? "correct" : "incorrect")

    // Haptic feedback m·∫°nh h∆°n cho k·∫øt qu·∫£
    if (navigator.vibrate) {
      if (isCorrect) {
        navigator.vibrate([50, 50, 50]) // Rung 3 l·∫ßn ng·∫Øn
      } else {
        navigator.vibrate(200) // Rung d√†i
      }
    }

    // C·∫≠p nh·∫≠t th·ªëng k√™
    this.learningState.totalAttempts++

    if (isCorrect) {
      this.handleCorrectAnswer()
    } else {
      this.handleIncorrectAnswer()
    }

    // T·ª± ƒë·ªông chuy·ªÉn sang t·ª´ ti·∫øp theo sau 1.5 gi√¢y
    setTimeout(() => {
      this.presentNextWord()
    }, 1500)
  }

  handleCorrectAnswer() {
    const currentWord = this.learningState.currentWord

    // C·∫≠p nh·∫≠t th·ªëng k√™
    this.learningState.correctAttempts++

    // X√≥a t·ª´ kh·ªèi h√†ng ƒë·ª£i v√† th√™m v√†o danh s√°ch ho√†n th√†nh
    this.learningState.vocabularyQueue.shift()
    this.learningState.completedWords.add(currentWord)

    // Ph·∫£n h·ªìi t√≠ch c·ª±c
    this.showFeedback(this.getRandomMessage("success"), "success")
  }

  handleIncorrectAnswer() {
    const currentWord = this.learningState.currentWord

    // X√≥a t·ª´ kh·ªèi ƒë·∫ßu h√†ng ƒë·ª£i v√† th√™m v√†o cu·ªëi ƒë·ªÉ l·∫∑p l·∫°i sau
    this.learningState.vocabularyQueue.shift()
    this.learningState.vocabularyQueue.push(currentWord)

    // Ph·∫£n h·ªìi khuy·∫øn kh√≠ch
    this.showFeedback(this.getRandomMessage("error"), "error", `ƒê√°p √°n ƒë√∫ng: "${this.learningState.correctAnswer}"`)
  }

  showFeedback(message, type, correctAnswer = "") {
    const feedbackElement = document.getElementById("feedback-message")
    const correctAnswerElement = document.getElementById("correct-answer")

    feedbackElement.textContent = message
    feedbackElement.className = `feedback-message ${type}`
    correctAnswerElement.textContent = correctAnswer

    // X√≥a ph·∫£n h·ªìi sau 1.5 gi√¢y
    setTimeout(() => {
      feedbackElement.textContent = ""
      feedbackElement.className = "feedback-message"
      correctAnswerElement.textContent = ""
    }, 1500)
  }

  updateAllDisplays() {
    this.updateHeaderStats()
    this.updateProgressIndicator()
  }

  updateHeaderStats() {
    const completed = this.learningState.completedWords.size
    const total = this.learningState.totalWords
    const accuracy =
      this.learningState.totalAttempts > 0
        ? Math.round((this.learningState.correctAttempts / this.learningState.totalAttempts) * 100)
        : 0

    document.getElementById("word-counter").textContent = `${this.learningState.currentPosition}/${total}`
    document.getElementById("accuracy-display").textContent = `${accuracy}%`
  }

  updateProgressIndicator() {
    const completed = this.learningState.completedWords.size
    const total = this.learningState.totalWords
    const remaining = this.learningState.vocabularyQueue.length
    const progress = total > 0 ? (completed / total) * 100 : 0

    document.getElementById("progress-fill").style.width = `${progress}%`
    document.getElementById("progress-text").textContent =
      `ƒê√£ ho√†n th√†nh ${completed}/${total} t·ª´ (${Math.round(progress)}%)`
    document.getElementById("remaining-count").textContent = `${remaining} c√≤n l·∫°i`
  }

  showCompletionModal() {
    const modal = document.getElementById("completion-modal")
    const accuracy =
      this.learningState.totalAttempts > 0
        ? Math.round((this.learningState.correctAttempts / this.learningState.totalAttempts) * 100)
        : 0

    document.getElementById("final-total").textContent = this.learningState.totalWords
    document.getElementById("final-attempts").textContent = this.learningState.totalAttempts
    document.getElementById("final-accuracy").textContent = `${accuracy}%`

    modal.style.display = "flex"

    // Haptic feedback cho ho√†n th√†nh
    if (navigator.vibrate) {
      navigator.vibrate([100, 50, 100, 50, 100]) // Rung m·ª´ng
    }
  }

  hideCompletionModal() {
    document.getElementById("completion-modal").style.display = "none"
  }

  togglePause() {
    this.learningState.isPaused = !this.learningState.isPaused
    const button = document.getElementById("pause-learning")

    if (this.learningState.isPaused) {
      button.textContent = "‚ñ∂Ô∏è Ti·∫øp t·ª•c"
      this.showFeedback("‚è∏Ô∏è ƒê√£ t·∫°m d·ª´ng h·ªçc t·∫≠p", "info")
    } else {
      button.textContent = "‚è∏Ô∏è T·∫°m d·ª´ng"
      this.showFeedback("‚ñ∂Ô∏è Ti·∫øp t·ª•c h·ªçc t·∫≠p", "info")
      setTimeout(() => this.presentNextWord(), 1000)
    }
  }

  restartSession() {
    // Reset tr·∫°ng th√°i v·ªÅ ban ƒë·∫ßu
    if (this.learningState.totalWords > 0) {
      // T·∫°o l·∫°i h√†ng ƒë·ª£i t·ª´ t·∫•t c·∫£ t·ª´ v·ª±ng
      const allWords = [...this.learningState.vocabularyQueue, ...Array.from(this.learningState.completedWords)]

      this.shuffleArray(allWords)

      this.learningState.vocabularyQueue = allWords
      this.learningState.completedWords.clear()
      this.learningState.currentPosition = 0
      this.learningState.totalAttempts = 0
      this.learningState.correctAttempts = 0
      this.learningState.isPaused = false

      document.getElementById("pause-learning").textContent = "‚è∏Ô∏è T·∫°m d·ª´ng"

      this.showFeedback("üîÑ ƒê√£ b·∫Øt ƒë·∫ßu l·∫°i! Ch√∫c b·∫°n h·ªçc t·ªët!", "success")
      setTimeout(() => this.presentNextWord(), 1000)
    }
  }

  getRandomMessage(type) {
    const messages = this.feedbackMessages[type]
    return messages[Math.floor(Math.random() * messages.length)]
  }

  shuffleArray(array) {
    for (let i = array.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1))
      ;[array[i], array[j]] = [array[j], array[i]]
    }
  }
}

// Kh·ªüi t·∫°o ·ª©ng d·ª•ng khi DOM ƒë√£ t·∫£i xong
document.addEventListener("DOMContentLoaded", () => {
  new VietnameseVocabularyLearner()
})
